% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/emfrail.R
\name{emfrail}
\alias{emfrail}
\title{Fitting shared frailty models wiht the EM algorithm}
\usage{
emfrail(.data, .formula, .distribution = emfrail_distribution(),
  .control = emfrail_control())
}
\arguments{
\item{.data}{A data frame in which the formula argument can be evaluated}

\item{.formula}{A formula that contains on the left hand side an object of the type \code{Surv} in the Andersen-Gill format, and on the right hand side a \code{+cluster(id)} statement}

\item{.distribution}{An object as created by \code{\link{emfrail_distribution}} which defines the frailty distribution. See Details.}

\item{.control}{An object as created by \code{\link{emfrail_control}}}
}
\value{
An object of the class \code{emfrail}, that is in fact a list which contains (1) the object returned by the
"outer maximization" from \code{optimx}, (2) the object with all the estimates returned by the "inner maximization",
(3) the log-likelihood of the Cox model without frailty, (4) the variance-covariance matrix adjusted for the uncertainty in the
outer maximization, and (5,6,7) are copies of the original input arguments: .formula, .distribution and .control.
}
\description{
Fitting shared frailty models wiht the EM algorithm
}
\details{
The \code{emfrail} function fits shared frailty models for processes which have intensity
\deqn{\lambda(t) = z \lambda_0(t) \exp(\gamma' \mathbf{x})}
with a non-parametric (Breslow) baseline intensity \eqn{\lambda_0(t)}.
The distribution of \eqn{z} is described by one parameter \eqn{\theta} (see the vignette on the available parametrizations).

The "inner" problem is that, for a fixed \eqn{\theta}, the log-likelihood \eqn{l_\theta} must be maximized with respect to
\eqn{\lambda_0(t)} and \eqn{\gamma}. This is done via an EM algorithm, which relies in the M step on the \code{agreg} function from the \code{survival} package.
From this EM algorithm, standard errors are obtained using Louis' formula.
The "outer" problem is that of maximizing \eqn{l_\theta} with respect to \eqn{\theta}. That is done using the \code{optimx} function
from the \code{optimx} package, which also provides the corresponding Hessian matrix.
The outer loop can be bypassed with the correct specification in the
\code{.control} argument, and the likelihood for the \eqn{\theta} as specified in the \code{.distribution} argument
is then returned.
The frailty distribution is determined by the \code{.distribution} argument. This must be generated by a call from
\code{emfrail_distribution()}.

The family of supported distributions can be one of gamma, positive stable or PVF (power-variance-family).
}
\note{
Some possible problems may appear when the maximum likelihood estimate lies on the border of the parameter space. Usually, this will happen
when the "outer" parameter MLE is infinity (i.e. variance 0 in case of gamma and PVF). For small enough values of \eqn{1/\theta} the log-likelihood
of the Cox model will be returned. The tolerance of this option can be tweaked in \code{emfrail_control()}.
}
\examples{
dat <- survival::rats
m1 <- emfrail(.data =  dat, .formula = Surv(rep(0, nrow(dat)), time, status) ~  rx + sex + cluster(litter),
.distribution = emfrail_distribution(dist = "gamma"))
m1

m2 <- emfrail(.data =  dat, .formula = Surv(rep(0, nrow(dat)), time, status) ~  rx + sex + cluster(litter),
              .distribution = emfrail_distribution(dist = "pvf"))
m2

m3 <- emfrail(.data =  dat, .formula = Surv(rep(0, nrow(dat)), time, status) ~  rx + sex + cluster(litter),
              .distribution = emfrail_distribution(dist = "stable"),
              .control = emfrail_control(verbose = FALSE))
m3




# draw the profile likelihood for different values of the frailty variance (gamma frailty)
fr_var <- c(0.001, 0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9)
prof_lik <- sapply(1/fr_var, function(th)
  -emfrail(.data =  dat, .formula = Surv(rep(0, nrow(dat)), time, status) ~  rx + sex + cluster(litter),
           .distribution = emfrail_distribution(frailtypar = th), .control = emfrail_control(opt_fit = FALSE))
)

plot(fr_var, prof_lik, xlab = "frailty variance", ylab = "log-likelihood")

# check with coxph:
prof_lik_cph <- sapply(fr_var, function(th)
  survival::coxph(data =  dat, formula = Surv(rep(0, nrow(dat)), time, status) ~ rx + sex + frailty(litter, theta = th),
                 method = "breslow")$history[[1]][[3]])

lines(fr_var, prof_lik_cph, col = 2)


# simulated data ----------------------------------------------------------
set.seed(1)
x <- sample(c(0,1), 300, TRUE)
z <- rep(rgamma(100, 1, 1), each = 3)

time <- rexp(300, rate = z * exp(0.5*x) )

censtime <- 5
status <- rep(1, 300)

status[time >= censtime] <- 0
time[status == 0] <- censtime
time0 <- rep(0, 300)

dd <- data.frame(id = rep(1:100, each = 3), x = x, time0 = time0, time = time, status = status)


emfrail(.data =  dd, .formula = Surv(rep(0, nrow(dat)), time, status) ~  x + cluster(id),
        .distribution = emfrail_distribution( dist = "stable"),
        .control = emfrail_control(opt_fit = TRUE))


#Recurrent events --------------------------------------------------------

data("bladder")
coxph(Surv(start, stop, status) ~ treatment + frailty(id), data = bladder1, method = "breslow")
mod2 <- emfrail(bladder1, Surv(start, stop, status) ~ treatment + cluster(id))

# Plotting the baseline cumulative hazard / intensity

with(mod2$res$haz,
     plot(time, cumhaz, type = "s", ylim = c(0, max(cumhaz) + 2 * max(se_chz_adj)),
     main = "Cumulative baseline hazard",
     ylab = "H0"))
with(mod2$res$haz, lines(time, cumhaz - 1.96*se_chz, col = 2))
with(mod2$res$haz, lines(time, cumhaz + 1.96*se_chz, col = 2))
with(mod2$res$haz, lines(time, cumhaz - 1.96*se_chz_adj, col = 3, lty = 2))
with(mod2$res$haz, lines(time, cumhaz + 1.96*se_chz_adj, col = 3, lty = 2))
legend(x = 0, y = 5, legend = c("95\% CI", "adjusted 95\% CI"), col = c(2,3), lty = c(1,2))

# with ggplot2
library(ggplot2)
ggplot(mod2$res$haz, aes(x = time)) +
geom_ribbon(aes(ymin = cumhaz - 1.96*se_chz, ymax = cumhaz + 1.96*se_chz),  fill = "grey70") +
  geom_ribbon(aes(ymin = cumhaz - 1.96*se_chz_adj, ymax = cumhaz + 1.96*se_chz_adj),  fill = "pink", alpha = 0.2) +
  geom_step(aes(y = cumhaz)) +
  ggtitle("Cumulative baseline hazard") +
  ylab("H0")


 # Left truncation
 # simulate 300 clusters of size 5
set.seed(17)
x <- sample(c(0,1), 5 * 300, TRUE)
u <- rep(rgamma(300,1,1), each = 5)
stime <- rexp(5*300, rate = u * exp(x))
ltime <- runif(5 * 300)

library(tidyverse)
d <- data.frame(id = rep(1:300, each = 5),
                x = x,
                stime = stime,
                u = u,
                ltime = ltime,
                status = 1)


d1 <- d \%>\% filter(stime > ltime)
 # this is the same as the cph (naive):
mymod <- d1 \%>\%
  emfrail(Surv(ltime, stime, status)~ x + cluster(id), .control = emfrail_control(verbose = TRUE))

 # this is the correct way here:
mymod <- d1 \%>\%
  emfrail(Surv(ltime, stime, status)~ x + cluster(id), .control = emfrail_control(verbose = TRUE),
          .distribution = emfrail_distribution(left_truncation = TRUE))
}
\seealso{
\code{\link{summary.emfrail}, \link{predict.emfrail}, \link{emfrail_distribution}, \link{emfrail_control}}
}

